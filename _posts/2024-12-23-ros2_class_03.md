---
layout: single
title:  "ROS2 AddTwoInts 사용 & Turtlebot3 Simulation"
categories: ros2
tag: ros2
toc: true
author_profile: false
sidebar:
    nav: "docs"
search: true
---

![Hits](https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https://{{ site.url | remove_first: 'https://' | remove_first: 'http://' }}{{ page.url }}&count_bg=%23FFCF00&title_bg=%230045FF&icon=macys.svg&icon_color=%23FAFF00&title=hits&edge_flat=false)
  
# AddTwoInts 사용해보자  
## cd robot_ws/src 에서 새로운 패키지 만들기  
```
ros2 pkg create py_srvcli --build-type ament_python --dependencies rclpy example_interfaces
```  

## cd py_srvcli 가서 service_member_function.py  
```python
from example_interfaces.srv import AddTwoInts  # AddTwoInts 서비스 메시지 타입 임포트

import rclpy  # ROS 2 Python 클라이언트 라이브러리 임포트
from rclpy.node import Node  # ROS 2 노드를 만들기 위한 Node 클래스 임포트


# AddTwoInts 서비스를 제공하는 서비스 서버 클래스 정의
class MinimalService(Node):


   # 생성자, 서비스 서버를 초기화
   def __init__(self):
       super().__init__('minimal_service')  # 부모 클래스(Node) 생성자 호출, 고유한 노드 이름 설정
       # 'add_two_ints' 서비스 생성, 이 서비스는 AddTwoInts 타입의 요청과 응답을 처리
       # 서비스가 호출되면 add_two_ints_callback 함수가 호출됩니다.
       self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)


   # AddTwoInts 서비스 요청을 처리하는 콜백 함수
   def add_two_ints_callback(self, request, response):
       # 요청으로 받은 a와 b를 더하여 응답 객체의 sum 필드에 저장
       response.sum = request.a + request.b
      
       # 요청 받은 값을 로그로 출력
       self.get_logger().info('Incoming request\na: %d b: %d' % (request.a, request.b))


       # 응답 객체를 반환하여 클라이언트에 결과를 전달
       return response

# 메인 함수, ROS 2 시스템 초기화 및 서비스 서버 실행
def main(args=None):
   rclpy.init(args=args)  # ROS 2 Python 클라이언트 라이브러리 초기화


   # MinimalService 서비스 서버 인스턴스 생성
   minimal_service = MinimalService()


   # 서비스가 요청을 받을 수 있도록 대기
   rclpy.spin(minimal_service)


   # 노드 종료 후 rclpy.shutdown() 호출하여 ROS 2 클라이언트 라이브러리 종료
   rclpy.shutdown()

# 이 파일이 직접 실행될 경우 main 함수 호출
if __name__ == '__main__':
   main()

```  

## cd py_srvcli 가서 client_member_function.py  
```python
import sys  # 커맨드 라인 인수 접근을 위한 sys 모듈 임포트


# example_interfaces 패키지에서 AddTwoInts 서비스 메시지 타입 임포트
from example_interfaces.srv import AddTwoInts
import rclpy  # ROS 2 Python 클라이언트 라이브러리 임포트
from rclpy.node import Node  # ROS 2 노드를 만들기 위한 Node 클래스 임포트


# AddTwoInts 서비스 클라이언트를 위한 MinimalClientAsync 클래스 정의
class MinimalClientAsync(Node):


   # 생성자, 클라이언트 노드를 초기화
   def __init__(self):
       super().__init__('minimal_client_async')  # 부모 클래스(Node) 생성자 호출, 고유한 노드 이름 설정
       # 'add_two_ints' 서비스와 통신하기 위한 클라이언트 생성
       self.cli = self.create_client(AddTwoInts, 'add_two_ints')


       # 서비스가 사용 가능할 때까지 1초마다 대기
       while not self.cli.wait_for_service(timeout_sec=1.0):
           self.get_logger().info('service not available, waiting again...')
      
       # AddTwoInts 서비스 요청 객체 생성
       self.req = AddTwoInts.Request()


   # a와 b 두 숫자를 받아서 요청을 보내는 메서드
   def send_request(self, a, b):
       # 요청 객체의 a와 b 필드에 값을 설정
       self.req.a = a
       self.req.b = b
      
       # 서비스를 비동기적으로 호출하고 미래(future) 객체에 결과를 저장
       self.future = self.cli.call_async(self.req)


       # 서비스 응답이 올 때까지 블로킹하여 대기
       rclpy.spin_until_future_complete(self, self.future)


       # 서비스 호출 결과를 반환
       return self.future.result()


# 메인 함수, ROS 2 시스템 초기화 및 서비스 호출
def main(args=None):
   rclpy.init(args=args)  # ROS 2 Python 클라이언트 라이브러리 초기화


   # MinimalClientAsync 클라이언트 노드 인스턴스 생성
   minimal_client = MinimalClientAsync()


   # 커맨드 라인 인수로 받은 두 숫자를 send_request 메서드에 전달하여 서비스 호출
   # sys.argv[1]과 sys.argv[2]는 커맨드 라인에서 입력된 두 숫자
   response = minimal_client.send_request(int(sys.argv[1]), int(sys.argv[2]))


   # 서비스 호출 결과 로그로 출력 (두 숫자의 합)
   minimal_client.get_logger().info(
       'Result of add_two_ints: for %d + %d = %d' %
       (int(sys.argv[1]), int(sys.argv[2]), response.sum))


   # 서비스 호출이 끝난 후 노드 파괴
   minimal_client.destroy_node()


   # ROS 2 클라이언트 라이브러리 종료
   rclpy.shutdown()


# 이 파일이 직접 실행될 경우 main 함수 호출
if __name__ == '__main__':
   main()

```  

## cd .. 해서 setup.py  
```
entry_points={
       'console_scripts': [
           'service = py_srvcli.service_member_function:main',
           'client = py_srvcli.client_member_function:main',
       ],
   },

```  

## ROS2 CLI 사용해서 보자  
```
ros2 service list

/*
/add_two_ints
/minimal_service/describe_parameters
/minimal_service/get_parameter_types
/minimal_service/get_parameters
/minimal_service/list_parameters
/minimal_service/set_parameters
/minimal_service/set_parameters_atomically
*/
```  

```
ros2 service type /add_two_ints 

/*
example_interfaces/srv/AddTwoInts
*/
```  

```
ros2 service call /add_two_ints example_interfaces/srv/AddTwoInts "{a: 12, b: 22}"

/*
waiting for service to become available...
requester: making request: example_interfaces.srv.AddTwoInts_Request(a=12, b=22)

response:
example_interfaces.srv.AddTwoInts_Response(sum=34)
*/
```  

<br />
<hr />
<br />
  
# 로보티즈 터틀봇3 시뮬레이션  
```
cd ~/turtlebot3_ws/src/
git clone -b foxy-devel https://github.com/ROBOTIS-GIT/turtlebot3_simulations.git
cd ~/turtlebot3_ws && colcon build --symlink-install
```  

## gazebo 설치  
```
sudo apt install ros-foxy-gazebo-*
```  

## turtlebot3 설치  
```
sudo apt install ros-foxy-turtlebot3*

# sudo apt install ros-foxy-turtlebot3-gazebo
# sudo apt install ros-foxy-turtlebot3-msgs
```  

## tutlebot3 simulation을 실행 후 ROS2 CLI 명령어로 정보 확인하기  

```
ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py
```  

```
ros2 topic list

/*
/clock
/cmd_vel
/imu
/joint_states
/odom
/parameter_events
/performance_metrics
/robot_description
/rosout
/scan
/tf
/tf_static
*/
```  

```
ros2 topic type /cmd_vel

/*
geometry_msgs/msg/Twist
*/
```  

```
ros2 topic type /scan

/*
sensor_msgs/msg/LaserScan
*/
```  

```
cat /opt/ros/foxy/share/sensor_msgs/msg/LaserScan.msg
```  

```
ros2 topic echo /scan
```  

아래와 같은 정보가 나오는데 - - - 로 반복해준다.  
레이더로 거리를 측정한 값을 보여주는데 장애물에 부딪히지 않고 끝까지 간 경우 .inf 로 나타낸다.  

```
---
header:
  stamp:
    sec: 347
    nanosec: 401000000
  frame_id: base_scan
angle_min: 0.0
angle_max: 6.28000020980835
angle_increment: 0.01749303564429283
time_increment: 0.0
scan_time: 0.0
range_min: 0.11999999731779099
range_max: 3.5
ranges:
- .inf
- .inf
- .inf
- .inf
- .inf
- .inf
- .inf
- 3.0582165718078613
- 3.0241169929504395
- 3.019754409790039
- 2.013763427734375
- 1.9856795072555542
- 1.948339819908142
- 1.9367854595184326
- 1.9440979957580566
- 1.943268060684204
- 1.9479233026504517
- 1.9877747297286987
- .inf
- .inf
- .inf
- 0.9902486205101013
- 0.9414001107215881
- 0.9330304861068726
- 0.9232556819915771
- 0.9300105571746826
- 0.9106385707855225
- 0.924481213092804
- 0.9105859398841858
- 0.9030020833015442
- 0.9116163849830627
- 0.9136989712715149
- 0.9052510857582092
- 0.9171230792999268
- 0.957747220993042
- 0.9810773134231567
- 1.0122859477996826
- 2.4367904663085938
- 2.4365363121032715
- 2.4128005504608154
- 2.4618146419525146
- 2.516110897064209
- .inf
- .inf
- .inf
- .inf
- .inf
- .inf
- .inf
- .inf
- .inf
- .inf
- .inf
- .inf
- .inf
- .inf
- 1.7563879489898682
- 1.715218424797058
- 1.716332197189331
- 1.6988532543182373
- 1.7058846950531006
- 1.7069318294525146
- 1.7188464403152466
- 1.7494845390319824
- 1.804458737373352
- 3.340061902999878
- 3.341921329498291
- 3.2981672286987305
- 3.2861180305480957
- 3.2389607429504395
- 3.225423574447632
- 3.231285333633423
- 3.196723222732544
- 3.073796033859253
- 2.8678627014160156
- 2.6851491928100586
- 2.5602240562438965
- 2.5606465339660645
- 2.538172960281372
- 2.544053316116333
- 2.550006866455078
- 2.5364344120025635
- 2.5117321014404297
- 2.541796922683716
- 2.5156400203704834
- 2.4279160499572754
- 2.3291687965393066
- 2.2564327716827393
- 2.1721057891845703
- 2.115628480911255
- 2.055629253387451
- 1.974146842956543
- 1.9506876468658447
- 1.879772663116455
- 1.8218913078308105
- 1.8104169368743896
- 1.7512900829315186
- 1.716362714767456
- 1.6654536724090576
- 1.63184654712677
- 1.5955030918121338
- 1.580954670906067
- 1.538205862045288
- 1.5027120113372803
- 1.4719213247299194
- 1.4413113594055176
- 1.4320321083068848
- 1.3993680477142334
- 1.373850703239441
- 1.3652151823043823
- 1.332464337348938
- 1.3060784339904785
- 1.3044440746307373
- 1.2909373044967651
- 1.267951250076294
- 1.2489559650421143
- 1.2368887662887573
- 1.2305915355682373
- 1.1978555917739868
- 1.2069110870361328
- 1.1976932287216187
- 1.1887149810791016
- 1.1584810018539429
- 1.1636221408843994
- 1.154280185699463
- 1.1418572664260864
- 1.104804277420044
- 1.1311993598937988
- '...'
intensities:
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- 0.0
- '...'
---
```  

<br />
<hr />
<br />

# turtlebot3 원격 키보드 제어 코드 만들기  

## cd ~/robot_ws/src 에서  

```
ros2 pkg create tb3_pkg --build-type ament_python --dependencies rclpy
```  

[로보티즈 터틀봇 관련](https://www.robotis.com/shop/item.php?it_id=901-0118-2021) 에서 사용하려는 터틀봇의 최대 이동 속도, 최대 회전 속도 등을 알아냄  

```
MAX_LIN_SPD = 0.22 # 최대 이동 속도
MIN_LIN_SPD = -0.22 # 최소 이동 속도
LIN_SPD_STP = 0.01 # 이동 속도 스텝
MAX_ANG_SPD = 2.84 # 최대 회전 속도
ANG_SPD_STP = 0.1 # 회전 속도 스텝
MIN_ANG_SPD = -2.84 # 최소 회전 속도
```  

## cd tb3_pkg/tb3_pkg 에 getchar.py 를 복붙함  
(내 블로그 ROS2 turtle keyboard 만들기 참고)  

## cd tb3_pkg/tb3_pkg 에서 remote_tb3.py  

```python
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
from .getchar import Getchar


MAX_LIN_SPD = 0.22 # 최대 이동 속도
MIN_LIN_SPD = -0.22 # 최소 이동 속도
LIN_SPD_STP = 0.01 # 이동 속도 스텝
MAX_ANG_SPD = 2.84 # 최대 회전 속도
ANG_SPD_STP = 0.1 # 회전 속도 스텝
MIN_ANG_SPD = -2.84 # 최소 회전 속도


msg = '''
Control Your TurtleBot3!
---------------------------
Moving around:
        w
   a    s    d
        x

w/x : increase/decrease linear velocity (Burger : ~ 0.22, Waffle and Waffle Pi : ~ 0.26)
a/d : increase/decrease angular velocity (Burger : ~ 2.84, Waffle and Waffle Pi : ~ 1.82)

space key, s : force stop

CTRL-C or Q to quit
'''

class Remote_TB3(Node):

    def __init__(self):
        super().__init__('remote_tb3')
        
def main(args=None):
    rclpy.init(args=args)

    node = Remote_TB3()
    kb = Getchar()
    tw = Twist()

    pub = node.create_publisher(Twist, '/cmd_vel', 10)
    
    try:
        print(msg)
        while rclpy.ok():

            key = kb.getch()

            if key == 'w':
                if tw.linear.x + LIN_SPD_STP <= MAX_LIN_SPD:
                    tw.linear.x = tw.linear.x + LIN_SPD_STP
                else:
                    tw.linear.x = MAX_LIN_SPD
            elif key == 'x':
                if tw.linear.x - LIN_SPD_STP >= MIN_LIN_SPD:
                    tw.linear.x = tw.linear.x - LIN_SPD_STP
                else:
                    tw.linear.x = MIN_LIN_SPD
            elif key == 'a':
                if tw.angular.z + ANG_SPD_STP <= MAX_ANG_SPD:
                    tw.angular.z = tw.angular.z + ANG_SPD_STP
                else:
                    tw.angular.z = MAX_ANG_SPD
            elif key == 'd':
                if tw.angular.z - ANG_SPD_STP >= MIN_ANG_SPD:
                    tw.angular.z = tw.angular.z - ANG_SPD_STP
                else:
                    tw.angular.z = MIN_ANG_SPD
            elif key == 's' or key == ' ':
                tw.linear.x = tw.angular.z = 0.0
            elif key == 'Q':
                print("Bye~")
                break
            else:
                pass

            pub.publish(tw)

            print("currently:	linear velocity %s	 angular velocity %s" % (tw.linear.x, tw.angular.z))
            
    except KeyboardInterrupt:
        node.destroy_node()
        rclpy.shutdown()


if __name__ == '__main__':
    main()
```  

## cd .. 해서 setup.py 'remote_tb3 = tb3_pkg.remote_tb3:main',  
```
entry_points={
       'console_scripts': [
           'remote_tb3 = tb3_pkg.remote_tb3:main',
       ],
   },

```  

## turtlebot3 원격 키보드 제어 코드 실행  
```
ros2 run tb3_pkg remote_tb3
```

<br />
<hr />
<br />

# gazebo 시작  
```
ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py 
```  
![20241223_01](/images/2024-12-23-ROS2_class/20241223_01.png){: width="70%" height="70%"}{: .center}  
<br />

# teleop keyboard 실행  
```
ros2 run turtlebot3_teleop teleop_keyboard
```  
<br />

# Cartographer SLAM 실행  
```
ros2 launch turtlebot3_cartographer cartographer.launch.py use_sim_time:=True
```  
![20241223_02](/images/2024-12-23-ROS2_class/20241223_02.png){: width="70%" height="70%"}{: .center}  
<br />

# Navigation 실행  
```
ros2 launch turtlebot3_navigation2 navigation2.launch.py use_sim_time:=True map:=$HOME/map.yaml
```  
![20241223_03](/images/2024-12-23-ROS2_class/20241223_03.png){: width="70%" height="70%"}{: .center}  

Cartographer SLAM 으로 occupancy grid map 지도를 만들었으면 키보드 제어 코드 끄고,  
2D Pose Estimate 방향 맞춰서 드래그  
Navigation2 Goal 로 드래그 하면 장애물 피해서 가는 것을 확인할 수 있음  
<br />

# 지도 저장  
```
ros2 run nav2_map_server map_saver_cli -f ~/map
```  
![20241223_04](/images/2024-12-23-ROS2_class/20241223_04.png){: width="70%" height="70%"}{: .center}  

<br />
<hr />
<br />

# 네비게이션 패키지 생성  

## cd ~/robot_ws/src 에서  
```
ros2 pkg create nav_pkg --build-type ament_python --dependencies rclpy
```  

## cd nav_pkg/nav_pkg 에서 follow_waypoints.py  
```python
import rclpy, sys,os
from rclpy.node import Node
from geometry_msgs.msg import PoseStamped 
from rclpy.action import ActionClient
from action_msgs.msg import GoalStatus
from nav2_msgs.action import FollowWaypoints

class ClientFollowPoints(Node):

    def __init__(self):
        super().__init__('client_follow_points')
        self._client = ActionClient(self, FollowWaypoints, '/FollowWaypoints')

    def send_points(self, points):
        msg = FollowWaypoints.Goal()
        msg.poses = points

        self._client.wait_for_server()
        self._send_goal_future = self._client.send_goal_async(msg, feedback_callback=self.feedback_callback)
        self._send_goal_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected')
            return

        self.get_logger().info('Goal accepted')

        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def get_result_callback(self, future):
        result = future.result().result
        status = future.result().status
        
        if status == GoalStatus.STATUS_SUCCEEDED:
            print("-----------------------------")
            print("arrived at goal position!!!!!")
            print("-----------------------------")
            #os.system("ros2 param set /reg_params go2wp2 go")
            sys.exit(1)
        
        self.get_logger().info('Result: {0}'.format(result.missed_waypoints))

    def feedback_callback(self, feedback_msg):
        feedback = feedback_msg.feedback
        self.get_logger().info('Received feedback: {0}'.format(feedback.current_waypoint))

def main(args=None):	
    rclpy.init(args=args)

    node = ClientFollowPoints()
    print('client inited')

    rgoal = PoseStamped()
    rgoal.header.frame_id = "map"
    rgoal.header.stamp.sec = 0
    rgoal.header.stamp.nanosec = 0
    rgoal.pose.position.z = 0.0
    rgoal.pose.position.x = 2.85
    rgoal.pose.position.y = 2.64
    rgoal.pose.orientation.w = 1.0
    print(rgoal)
    mgoal = [rgoal]
    
    node.send_points(mgoal)

    rclpy.spin(node)
```  

## cd .. 해서 setup.py에서 'follow_waypoints = nav_pkg.follow_waypoints:main',  
```
entry_points={
        'console_scripts': [
            'follow_waypoints = nav_pkg.follow_waypoints:main',
        ],
    },
```  

당연히 빌드 하고, 소스 하고,  

## 확인해보자  

### gazebo 실행  
```
ros2 launch turtlebot3_gazebo turtlebot3_world.launch.py
```  

### navigation 실행  
```
ros2 launch turtlebot3_navigation2 navigation2.launch.py use_sim_time:=True map:=$HOME/map.yaml
```  

### 특정 포인트로 가도록 짠 코드 실행  
```
ros2 run nav_pkg follow_waypoints
```  

![20241224_01](/images/2024-12-23-ROS2_class/20241224_01.png){: width="50%" height="50%"}{: .center} 
![20241224_02](/images/2024-12-23-ROS2_class/20241224_02.png){: width="50%" height="50%"}{: .center}  

## 좌표 알아내기  

RViz 에 Publish Point 클릭 후 좌표를 갖다 대면 좌측 하단 숫자 배열을 볼 수 있다.  

![20241224_03](/images/2024-12-23-ROS2_class/20241224_03.png){: width="70%" height="70%"}{: .center}  

follow_waypoints.py를 복사해서 follow_waypoints1.py, follow_waypoints2.py, follow_waypoints3.py, follow_waypoints4.py 로 만들어봤다.  
그리고나서 약 61, 62째 줄에  
rgoal.pose.position.x = 2.94  
rgoal.pose.position.y = -0.966  
에 숫자를 바꾼다.  
그리고 setup.py 에도 해야 할 일을 한다.  

```
entry_points={
        'console_scripts': [
            'follow_waypoints1 = nav_pkg.follow_waypoints1:main',
            'follow_waypoints2 = nav_pkg.follow_waypoints2:main',
            'follow_waypoints3 = nav_pkg.follow_waypoints3:main',
            'follow_waypoints4 = nav_pkg.follow_waypoints4:main',
        ],
    },
```  

빌드 잘 하고 위에서 터미널에서 했던 거 gazebo 실행, navigation 잘 하고,  
follow_waypoints1, follow_waypoints2, follow_waypoints3, follow_waypoints4 중에 멋대로 하면 됨  

```
ros2 run nav_pkg follow_waypoints1
```  

<br />
<hr />
<br />

# [로보티즈](https://www.robotis.com/) 사이트  
wayback machine 에서 로보티즈 사이트의 2024/03/09에서 알아낸 정보  
딱히 안해도 됨   
```
sudo apt install ros-foxy-cartographer
sudo apt install ros-foxy-cartographer-ros

sudo apt install ros-foxy-navigation2
sudo apt install ros-foxy-nav2-bringup

sudo apt install ros-foxy-dynamixel-sdk
sudo apt install ros-foxy-turtlebot3-msgs
sudo apt install ros-foxy-turtlebot3

source ~/.bashrc
```  