---
layout: single
title:  "AI Class 01 01 05 Python Data Structure"
categories: python
tag: python
toc: true
author_profile: false
sidebar:
    nav: "docs"
search: true
---

![Hits](https://hits.seeyoufarm.com/api/count/incr/badge.svg?url=https://{{ site.url | remove_first: 'https://' | remove_first: 'http://' }}{{ page.url }}&count_bg=%23FFCF00&title_bg=%230045FF&icon=macys.svg&icon_color=%23FAFF00&title=hits&edge_flat=false)

## Stack 스택  
- 나중에 넣은 데이터를 먼저 반환하도록 설계된 메모리 구조  
- Last In First Out (LIFO)  
- Data의 입력을 Push, 출력을 Pop  
- 리스트를 사용하여 스택 구조 구현 가능  
- push를 append(), pop을 pop()  

```python
a = [1, 2, 3, 4, 5]
a.append(10)
a
```  
>  
결과  
```
    [1, 2, 3, 4, 5, 10]
```  
```python
a.append(20)
a
```  
>  
결과  
```
    [1, 2, 3, 4, 5, 10, 20]
```  
```python
c = a.pop()
a
```  
>  
결과  
```
    [1, 2, 3, 4, 5, 10]
```  
```python
c
```  
>  
결과  
```
    20
```  
```python
d = a.pop()
a
```  
>  
결과  
```
    [1, 2, 3, 4, 5]
```  

- 스택 구조를 활용하여 입력된 글자를 역순으로 출력  
```python
word = input("input a word: ")
word_list = list(word)
for i in range(len(word_list)):
    print(word_list.pop())
    print(word_list)
```  
>  
결과  
```
    input a word: hello # 직접 입력
    o
    ['h', 'e', 'l', 'l']
    l
    ['h', 'e', 'l']
    l
    ['h', 'e']
    e
    ['h']
    h
    []
```  

## Queue 큐  
- 먼저 넣은 데이터를 먼저 반환하도록 설계된 메모리 구조  
- First In First Out (FIFO)  
- Stack과 반대되는 개념  
- 파이썬은 리스트를 사용하여 큐 구조를 활용  
- put를 append(), get을 pop(0)  
```python
a = [1, 2, 3, 4, 5]
a.append(10)
a.append(20)
five = a.pop(4)
five
```  
>  
결과  
```
    5
```  
```python
a
```  
>  
결과  
```
    [1, 2, 3, 4, 10, 20]
```  

## Tuple 튜플  
- 값의 변경이 불가능한 리스트  
- 선언 시 "[]"가 아닌 "()"를 사용  
- 리스트의 연산, 인덱싱, 슬라이싱 등을 동일하게 사용  
```python
t = (1, 2, 3)
print(t + t, t * 2)
```  
>  
결과  
```
    (1, 2, 3, 1, 2, 3) (1, 2, 3, 1, 2, 3)
```  
```python
len(t)
```  
>  
결과  
```
    3
```  
```python
t[1] = 5 # 할당이 안되어서 Error 발생
```  
>  
결과  
```
    Traceback (most recent call last)
    File "<stdin>" in <module>
    ----> 1 t[1] = 5
    TypeError: 'tuple' object does not support item assignment
```  
- 왜 쓸까?
    - 프로그램을 작동하는 동안 변경되지 않은 데이터의 저장  
    - ex) 학번, 이름, 우편번호 등등  
    - 함수의 반환값 등 사용자의 실수에 의한 에러를 사전에 방지  
    ```python
    t = (1) # 일반 정수로 인식
    ```  
    >  
    결과  
    ```
        1
    ```  
    - 값이 하나인 Tuple은 반드시 , 를 붙여야 한다  
    ```python
    t = (1, ) # 값이 하나인 Tuple은 반드시 ","를 붙여야 함
    ```
    >  
    결과  
    ```
        (1, )
    ```  

## set 집합  
- 값을 순서 없이 저장, 중복 불허 하는 자료형  
- set 객체 선언을 이용하여 객체 생성  
```python
s = set([1,2,3,1,2,3]) # set 함수를 사용 1,2,3을 집합 객체 생성, s={1,2,3,4,5}도 가능
s
```  
>  
결과  
```
    {1, 2, 3}
```  
```python
s.add(1) # 한 원소 1만 추가,  추가,중복불허로 추가되지 않음
s
```  
>  
결과  
```
    {1, 2, 3}
```  
```python
s.remove(1) # 1 삭제
s
```  
>  
결과  
```
    {2, 3}
```  
```python
s.update([1,4,5,6,7]) # [1,4,5,6,7] 추가
s
```  
>  
결과  
```
    {1, 2, 3, 4, 5, 6, 7}
```  
```python
s.discard(3) # 3 삭제
s
```  
>  
결과  
```
    {1, 2, 4, 5, 6, 7}
```  
```python
s.clear() # 모든 원소 삭제
s
```  
>  
결과  
```
    set()
```  

- 수학에서 활용하는 다양한 집합연산 가능  
```python
s1 = set([1,2,3,4,5])
s2 = set([3,4,5,6,7])
s1.union(s2) # s1과 s2의 합집합
```  
>  
결과  
```
    {1, 2, 3, 4, 5, 6, 7}
```  
```python
s1 | s2 # set([1,2,3,4,5,6,7])
```  
>  
결과  
```
    {1, 2, 3, 4, 5, 6, 7}
```  
```python
s1.intersection(s2) # s1과 s2의 교집합
```  
>  
결과  
```
    {3, 4, 5}
```  
```python
s1 & s2 # set([3,4,5])
```  
>  
결과  
```
    {3, 4, 5}
```  
```python
s1.difference(s2) # s1과 s2의 차집합
```  
>  
결과  
```
    {1, 2}
```  
```python
s1 - s2 # set([1,2])
```  
>  
결과  
```
    {1, 2}
```  

## dictionary 사전  
- 데이터를 저장할 때는 구분 지을 수 있는 값을 함께 저장(ex. 주민등록번호, 제품모델번호)  
- 구분을 위한 데이터 교유값을 Identifier 또는 Key라고 함  
- key 값을 활용하여, 데이터값(Value)를 관리함  
- key와 value를 매칭하여 key로 value를 검색  
- 다른 언어에서는 Hash Table이라는 용어를 사용  
- {Key1:Value1, Key2:Value2, Key3:Value3...} 형태  

```python
country_code = {} # Dict 생성, country_code = dict()도 가능
country_code = {"America":1, "Korea":82, "China":86, "Japan":81}
country_code
```  
>  
결과  
```
    {'America': 1, 'Korea': 82, 'China': 86, 'Japan': 81}
```  
```python
country_code.items() # Dict 데이터 출력
```  
>  
결과  
```
    dict_items([('America', 1), ('Korea', 82), ('China', 86), ('Japan', 81)])
```  
```python
country_code.keys() # Dict 키 값만 출력
```  
>  
결과  
```
    dict_keys(['America', 'Korea', 'China', 'Japan'])
```  
```python
country_code["German"] = 49 # Dict 추가
country_code
```  
>  
결과  
```
    {'America': 1, 'Korea': 82, 'China': 86, 'Japan': 81, 'German': 49}
```  
```python
country_code.values()
```  
>  
결과  
```
    dict_values([1, 82, 86, 81, 49])
```  
```python
for k, v in country_code.items():
    print("Key : ", k)
    print("Value : ", v)
```  
>  
결과  
```
    Key :  America
    Value :  1
    Key :  Korea
    Value :  82
    Key :  China
    Value :  86
    Key :  Japan
    Value :  81
    Key :  German
    Value :  49
```  

## Command Analyzer  
- Command: 사용자가 서버에 명령어를 입력한 명령어  
- 어떤 사용자가 얼마나 많이 명령어를 입력하였을까?  
- Data source: https://bit.ly/3nR3qFa  

29:50




































최성철 교수의 인공지능(AI) 강의를 들으며 정리하였습니다.  
또한 이곳저곳에서 구글링하며 공부하였습니다.  